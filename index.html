<html>
  <head>
    <link href="main.css">
    <style>
      canvas {
        background-size: cover;
        background-image: url(https://i0.wp.com/sitn.hms.harvard.edu/wp-content/uploads/2020/07/Mars_zichtbaar_vanaf_de_alpe_du_hues-scaled.jpg?resize=1000/1000=1);
      }
    </style>
    <body onload="startGame()">
      <script type="text/javascript">
         
        
        //obstacle.size
        class Obstacle {
          constructor() {
            this.maxHeight = 150;
            this.minHeight = 200;
            this.minWidth = 10;
            this.maxWidth = 80;
            this.minGap = 200;
            this.maxGap = 500;
            
          }
          randGap() {
            return Math.floor(
              this.minGap + Math.random() * (this.maxGap - this.minGap + 1)
            );
          }
          draw() {
            gamearea.context.fillRect(1840,850, this.maxWidth, this.maxHeight);
          }
        }
        let myobstacle = new Obstacle();
        

        var myObstacles = [];
        function startGame() {
          gamearea.start();
        }
        //interval.for.obstacle
        function everyinterval(n) {
          if (gamearea.frame % n == 0) return true;
          return false;
        }

        //player1
        var player = {
          x: 10,
          y:850,
          speedY: 100,
          currentJumpHeight:0,
          jump() {
            console.log(player.currentJumpHeight)
            // gamearea.context.translate (0,this.speedY)
            var img = new Image(); // Create new img element
            img.src = "./assets/png/Idle.png"; // Set source path
            //gamearea.context.drawImage(img, 0, 400, 100, 100);

 if(player.currentJumpHeight < 15) {
    console.log(player.currentJumpHeight)
  gamearea.context.clearRect(0, 0,player.x,player.y)
  gamearea.context.translate(0, -20);
  gamearea.context.drawImage(img, 0, 400, player.x,player.y);
    setTimeout(function (){
        player.jump()
    },15)
    player.currentJumpHeight++
  } else {
    fall()
  }


//clearing.the.jump
//newPos:function() {
   // if(player.y<280)=2;
//}
//player.y=player.yplayer.speedY;
//if(player.speedY==2 && player.y==850) {
   // player.speedY=0;
//}

function fall() {
  if(player.currentJumpHeight > 0) {
    console.log(player.currentJumpHeight)
    gamearea.context.clearRect(0,0,player.x,player.y)
    gamearea.context.translate(0, 20);
    gamearea.context.drawImage(img, 0, 200, player.x,player.y);
    setTimeout(function (){
        fall()
    },50)
    player.currentJumpHeight--
  }
}
      },
          update: function () {
            var img = new Image(); // Create new img element
            img.src = "./assets/png/Idle.png"; // Set source path
            gamearea.context.drawImage(img, this.x, this.y);
          },
        };
        //game.scale
        //map=obstacle
        function map() {
          this.height = Math.floor(
            minHeight + Math.random() * (maxHeight - minHeight + 1)
          );
          this.width = Math.floor(
            maxWidth + Math.random() * (maxWidth - minWidth + 1)
          );
          this.draw = function () {
            //x=1200;
            // y=gamearea.canvas.height-this.height;
            //gamearea.context.fillRect(x,y,this.width,this.height)
          };
        }
        //size.of.the.game
        var gamearea = {
          canvas: document.createElement("canvas"),
          start: function () {
            this.canvas.height = 1000;
            this.canvas.width = 1900;

            document.body.insertBefore(
              this.canvas,
              document.body.childNodes[0]
            );
            this.frame = 0;
            this.context = this.canvas.getContext("2d");

            this.interval = setInterval(this.updateGameArea, 4);
            window.addEventListener("keydown", player.jump);
          },

          //randomizingObstacle
          updateGameArea: function () {
            gamearea.clear();
            //if(everyinterval (gap)){
            let updatedobstacle = new Obstacle();
            myObstacles.push(updatedobstacle);
            let gap = updatedobstacle.randGap();
            gamearea.frame = 0;
            // }
            for (i = 0; i < myObstacles.length; i++) {
              myObstacles[i].x = -1;
              myObstacles[i].draw();
            }
            player.update();
            gamearea.frame += 1;
          },
          clear: function () {
            gamearea.context.clearRect(
              0,
              0,
              this.canvas.width,
              this.canvas.width
            );
          },
          stop: function () {},
        };
      </script>
    </body>
  </head>
</html> 